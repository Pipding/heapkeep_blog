---
layout: post
title: "The role of NDepend in HeapKeep"
date: 2025-05-12 19:00:00 +0000
categories: blog
---

<div style="background-color: #f0f0f0; padding: 1em; border-left: 4px solid #ccc; margin-bottom: 1em;">
  <strong>Disclaimer:</strong> A free NDepend license was provided for the development of HeapKeep on the condition that I document and share NDepend's role in the project. Opinions, analysis and viewpoints expressed in this post are solely my own.
</div>

# What is HeapKeep?
In case you're reading this with no prior knowledge of the project, HeapKeep is an experimental code visualization inspired by RPG video games. The idea is pretty simple - the player explores a dungeon, similar to dungeon crawler games like Baldur's Gate or Diablo, except instead of a randomly-generated floor plan, the dungeon layout is an abstract representation of a codebase dependency graph. If that sounds complicated, don't worry - I'll go over the ins-and-outs in this post. In the meantime, here's a gameplay video.

<div style="text-align: center;">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Q66gCaC4dT8?si=d7r6GEEWiDnvc836" title="HeapKeep Beta gameplay" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>
<br>

# How HeapKeep's level layout was made
HeapKeep was developed using the Unreal Engine version of [Dungeon Architect](https://dungeonarchitect.dev/), a procedural generation tool with several graph-based level design workflows. Since I needed my level to have a fairly specific structure, I actually didn't use too many of the procedural generation features of Dungeon Architect. Instead, I made a static level graph which could be used to generate slightly different levels with a rigid structure. The image below is a simplified version of the level graph, but hopefully it conveys the idea.

<p style="text-align: center;">
  <img src="{{ "/assets/images/2025-05-12-da_singleton_graph.jpg" | relative_url }}" alt="A simplified version of the level layout graph used in HeapKeep" style="max-width: 100%; height: auto;">
</p>

So the level is based on this graph and this graph is based on a codebase. But how do we turn a codebase into a graph? That's where NDepend comes in.

# Why NDepend?
There's actually a whole separate blog post about [why I chose NDepend for this project](https://pipding.github.io/heapkeep_blog/blog/2025/02/23/analyzing_codebase.html)


# How NDepend was used to construct the level layout
NDepend is a versatile code analysis tool, available as a Visual Studio extension. It can be used to analyze .NET projects in multiple ways including code quality analysis, monitoring test coverage, architecture analysis, etc. For HeapKeep, I was particularly interested in its diagramming capabilities.

The level layout in HeapKeep is based on the codebase for a MonoGame sample project called [NeonShooter](https://github.com/MonoGame/MonoGame.Samples/tree/3.8.2/NeonShooter). I loaded up the NeonShooter codebase into Visual Studio, analysed it with NDepend and generated a dependency graph. The resulting graph, shown below, was interesting and offered plenty of insight into the NeonShooter codebase, but it was too complex for me to represent in 3D space.

<p style="text-align: center;">
  <img src="{{ "/assets/images/2025-05-12-ndepend_neonshooter_graph_default.jpg" | relative_url }}" alt="The default dependency graph generated by NDepend for the NeonShooter codebase" style="max-width: 80%; height: auto;">
</p>

Fortunately, NDepend has a field where you can specify the query used to generate the dependency graph. The default query is simply:
```csharp
Types
```

Which, as you might expect, includes all types in the project. With some [help from ChatGPT](https://chatgpt.com/share/67c8b8bf-cc74-8010-9375-8792eaa3cf9d) I was able to generate the following query, which narrowed the graph down to;
- Include only types in the NeonShooter.Core assembly
- Exclude nested types
- Exclude enums

Here's the adjusted query:
```csharp 
// <Name>Classes children, callers, and callees of the assembly NeonShooter.Core (excluding nested classes)</Name>
let assemblies = Assemblies.WithNameIn("NeonShooter.Core")

let children = assemblies.ChildTypes()
    .Where(t => t.IsClass && t.ParentType == null)
    .Select(t => new { elem = t, kind = "child" })

let callers = Application.Types.UsingAny(assemblies)
    .Where(t => t.IsClass && t.ParentType == null)
    .Select(t => new { elem = t, kind = "caller" })

let callees = Types.UsedByAny(assemblies)
    .Where(t => t.IsClass && t.ParentType == null)
    .Select(t => new { elem = t, kind = "callee" })

from t in children.Concat(callers).Concat(callees).Distinct(pair => pair.elem) 
select t
```

This query generated the following pared-down and more manageable dependency graph.

<p style="text-align: center;">
  <img src="{{ "/assets/images/2025-05-12-ndepend_neonshooter_graph_refined.jpg" | relative_url }}" alt="A refined version of the dependency graph for the NeonShooter codebase" style="max-width: 80%; height: auto;">
</p>

In order to simplify this graph even further for the level layout, I decided to represent only one connection between each class. Starting from the `GameRoot` class at the top of the diagram, I followed a left-hand-first traversal strategy, adding each class to the level layout graph as I went. This resulted in that simple level layout graph I showed earlier. Then I simply added corridors between each room and presto, a level graph.

<p style="text-align: center;">
  <img src="{{ "/assets/images/2025-05-12-heapkeep_level_layout_graph.jpg" | relative_url }}" alt="The full level layout graph used in HeapKeep" style="max-width: 100%; height: auto;">
</p>

When run through Dungeon Architect's procedural generation algorithm, this graph generated a nicely interconnected level.

<p style="text-align: center;">
  <img src="{{ "/assets/images/2025-05-12-heapkeep_overview.jpg" | relative_url }}" alt="A bird's eye view of the HeapKeep level layout" style="max-width: 80%; height: auto;">
</p>


# How NDepend code metrics informed level design
In addition to basing the level layout on a dependency graph, the decor of the level was determined by code metrics measured using NDepend. Each room in the dungeon represents a class in the codebase, with the size of the room directly determined by the line count of the class. Strictly speaking it's actually statement count because NDepend counts statements, not raw lines of code. Statement count is probably a more useful metric because it's not impacted by formatting. For example consider this snippet:
```java
for (i = 0; i < 100; i++)
{
    printf("hello");
}
```

This loop spans 4 lines but the same logic can be written in a single line:

```java
for (i = 0; i < 100; i++) printf("hello");
```

While the line count varies based on formatting, what remains unambiguous is that there are 2 statements; the for loop and the printf call.

**Anyway**, with that tangent over, the cyclomatic complexity of each class was also used to inform how the rooms were decorated. Classes with low cyclomatic complexity were decorated with treasure (like the `MathUtils` class represented on the left in the image below) while classes with high cyclomatic complexity were decorated with skeletons and torture implements (like the `Art` class on the right).

<p style="text-align: center;">
  <img src="{{ "/assets/images/2025-05-12-room-complexity-comparison.jpg" | relative_url }}" alt="A comparison of the decor of a room representing a class with low cyclomatic complexity vs a room representing a class with high cyclomatic complexity" style="max-width: 100%; height: auto;">
</p>


# Bonus stats
NDepend produces a code report as a static webpage after analysing a project. You can check out the full report for the NeonShooter codebase here: [NeonShooter NDepend Analysis]({{ "assets/webpages/ndepend/reports/neonshooter_2025-02-22/NDependReport.html" | relative_url }})